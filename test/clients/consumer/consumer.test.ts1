import { deepStrictEqual, ok, rejects, strictEqual } from 'node:assert'
import { randomUUID } from 'node:crypto'
import { test } from 'node:test'
import {
  Consumer,
  ConsumerOptions,
  FindCoordinatorKeyTypes,
  MessagesStream,
  MessagesStreamModes,
  Producer,
  ProduceAcks,
  stringDeserializers,
  stringSerializers,
  UserError
} from '../../../src/index.ts'

const kafkaBootstrapServers = ['localhost:29092']

// Helper function to create a unique test consumer
function createTestConsumer<K = Buffer, V = Buffer, HK = Buffer, HV = Buffer>(
  overrideOptions: Partial<ConsumerOptions<K, V, HK, HV>> = {}
) {
  const options: ConsumerOptions<K, V, HK, HV> = {
    clientId: `test-client-${randomUUID()}`,
    bootstrapBrokers: kafkaBootstrapServers,
    groupId: `test-consumer-group-${randomUUID()}`,
    ...overrideOptions
  }
  return new Consumer<K, V, HK, HV>(options)
}

// Helper function to generate a unique topic name
function getTestTopicName() {
  return `test-topic-${randomUUID()}`
}

// Helper function to produce test messages to a topic
async function produceTestMessages(topic: string, count = 3) {
  const producer = new Producer({
    clientId: `test-producer-${randomUUID()}`,
    bootstrapBrokers: kafkaBootstrapServers,
    serializers: stringSerializers,
    autocreateTopics: true
  })

  try {
    for (let i = 0; i < count; i++) {
      await producer.send({
        messages: [
          {
            topic,
            key: `key-${i}`,
            value: `value-${i}`,
            headers: { headerKey: `headerValue-${i}` }
          }
        ],
        acks: ProduceAcks.LEADER
      })
    }
  } finally {
    await producer.close()
  }
}

test('Consumer client - constructor should initialize properly', () => {
  const consumer = createTestConsumer()

  strictEqual(consumer instanceof Consumer, true)
  strictEqual(consumer.closed, false)
  strictEqual(consumer.groupId.startsWith('test-consumer-group-'), true)
  strictEqual(consumer.generationId, 0)
  strictEqual(consumer.memberId, null)
  strictEqual(consumer.assignments, null)

  consumer.close()
})

test('Consumer client - constructor should validate options in strict mode', () => {
  // Test with missing required groupId
  try {
    // @ts-expect-error - Intentionally passing invalid options
    // eslint-disable-next-line no-new
    new Consumer({
      clientId: 'test-client',
      bootstrapBrokers: kafkaBootstrapServers,
      strict: true
    })
    throw new Error('Should have thrown for missing groupId')
  } catch (error: any) {
    ok(error.message.includes('groupId'), 'Error message should mention groupId')
  }

  // Test with invalid heartbeatInterval type
  try {
    // eslint-disable-next-line no-new
    new Consumer({
      clientId: 'test-client',
      bootstrapBrokers: kafkaBootstrapServers,
      groupId: 'test-group',
      // @ts-expect-error - Intentionally passing invalid option type
      heartbeatInterval: 'not-a-number',
      strict: true
    })
    throw new Error('Should have thrown for invalid heartbeatInterval type')
  } catch (error: any) {
    ok(error.message.includes('heartbeatInterval'), 'Error message should mention heartbeatInterval')
  }

  // Test with invalid session timeout
  try {
    // eslint-disable-next-line no-new
    new Consumer({
      clientId: 'test-client',
      bootstrapBrokers: kafkaBootstrapServers,
      groupId: 'test-group',
      sessionTimeout: -1, // Negative value
      strict: true
    })
    throw new Error('Should have thrown for negative sessionTimeout')
  } catch (error: any) {
    ok(error.message.includes('sessionTimeout'), 'Error message should mention sessionTimeout')
  }

  // Valid options should work without throwing
  const consumer = new Consumer({
    clientId: 'test-client',
    bootstrapBrokers: kafkaBootstrapServers,
    groupId: 'test-group',
    sessionTimeout: 30000,
    rebalanceTimeout: 30000,
    heartbeatInterval: 3000,
    strict: true
  })
  strictEqual(consumer instanceof Consumer, true)
  consumer.close()
})

test('Consumer client - validateGroupOptions should throw with invalid configurations', () => {
  // Test with rebalanceTimeout < sessionTimeout
  try {
    // eslint-disable-next-line no-new
    new Consumer({
      clientId: 'test-client',
      bootstrapBrokers: kafkaBootstrapServers,
      groupId: 'test-group',
      sessionTimeout: 30000,
      rebalanceTimeout: 20000, // Less than sessionTimeout
      strict: true
    })
    throw new Error('Should have thrown for rebalanceTimeout < sessionTimeout')
  } catch (error: any) {
    ok(error.message.includes('rebalanceTimeout'), 'Error message should mention rebalanceTimeout')
  }

  // Test with heartbeatInterval > sessionTimeout
  try {
    // eslint-disable-next-line no-new
    new Consumer({
      clientId: 'test-client',
      bootstrapBrokers: kafkaBootstrapServers,
      groupId: 'test-group',
      sessionTimeout: 30000,
      rebalanceTimeout: 30000,
      heartbeatInterval: 40000, // Greater than sessionTimeout
      strict: true
    })
    throw new Error('Should have thrown for heartbeatInterval > sessionTimeout')
  } catch (error: any) {
    ok(error.message.includes('heartbeatInterval'), 'Error message should mention heartbeatInterval')
  }

  // Test with heartbeatInterval > rebalanceTimeout
  try {
    // eslint-disable-next-line no-new
    new Consumer({
      clientId: 'test-client',
      bootstrapBrokers: kafkaBootstrapServers,
      groupId: 'test-group',
      sessionTimeout: 10000,
      rebalanceTimeout: 20000,
      heartbeatInterval: 30000, // Greater than rebalanceTimeout
      strict: true
    })
    throw new Error('Should have thrown for heartbeatInterval > rebalanceTimeout')
  } catch (error: any) {
    ok(error.message.includes('heartbeatInterval'), 'Error message should mention heartbeatInterval')
  }
})

test('Consumer client - should support both promise and callback API', (_, done) => {
  const consumer = createTestConsumer()

  // Use callback API for findGroupCoordinator
  consumer.findGroupCoordinator((err, coordinatorId) => {
    strictEqual(err, null)
    strictEqual(typeof coordinatorId, 'number')
    strictEqual(coordinatorId > 0, true)

    // Clean up and close
    consumer
      .close()
      .then(() => done())
      .catch(done)
  })
})

test('Consumer client - all operations should fail when client is closed', async () => {
  const consumer = createTestConsumer()

  // Close the client first
  await consumer.close()

  // Attempt to call methods on a closed client
  await rejects(
    async () => {
      await consumer.findGroupCoordinator()
    },
    (error: any) => {
      strictEqual(error instanceof UserError, true)
      strictEqual(error.message, 'Client is closed.')
      return true
    }
  )

  await rejects(
    async () => {
      await consumer.consume({
        topics: ['test-topic']
      })
    },
    (error: any) => {
      strictEqual(error instanceof UserError, true)
      strictEqual(error.message, 'Client is closed.')
      return true
    }
  )

  await rejects(
    async () => {
      await consumer.joinGroup({})
    },
    (error: any) => {
      strictEqual(error instanceof UserError, true)
      strictEqual(error.message, 'Client is closed.')
      return true
    }
  )

  // Attempt to call close again on already closed client
  // This shouldn't throw but should resolve normally
  await consumer.close()
})

test('Consumer client - findGroupCoordinator should return coordinator ID', async () => {
  const consumer = createTestConsumer()

  try {
    const coordinatorId = await consumer.findGroupCoordinator()
    strictEqual(typeof coordinatorId, 'number')
    strictEqual(coordinatorId > 0, true)

    // Second call should use cached coordinator ID and return same value
    const cachedCoordinatorId = await consumer.findGroupCoordinator()
    strictEqual(cachedCoordinatorId, coordinatorId)
  } finally {
    await consumer.close()
  }
})

test('Consumer client - joinGroup should join a consumer group', async () => {
  const consumer = createTestConsumer()
  const testTopic = getTestTopicName()

  try {
    // Track the test topic first
    await consumer.topics.trackAll(testTopic)

    // Join the consumer group
    const memberId = await consumer.joinGroup({})

    // Verify that memberId is set properly
    strictEqual(typeof memberId, 'string')
    strictEqual(memberId.length > 0, true)
    strictEqual(consumer.memberId, memberId)
    strictEqual(consumer.generationId > 0, true)

    // Verify assignments are set
    ok(Array.isArray(consumer.assignments))
    strictEqual(consumer.assignments!.length, 1) // Should have one entry for our topic
    strictEqual(consumer.assignments![0].topic, testTopic)
    strictEqual(Array.isArray(consumer.assignments![0].partitions), true)
  } finally {
    await consumer.close(true)
  }
})

test('Consumer client - leaveGroup should leave a consumer group', async () => {
  const consumer = createTestConsumer()
  const testTopic = getTestTopicName()

  try {
    // Track the test topic and join the group
    await consumer.topics.trackAll(testTopic)
    await consumer.joinGroup({})

    const originalMemberId = consumer.memberId
    strictEqual(typeof originalMemberId, 'string')
    strictEqual(originalMemberId!.length > 0, true)

    // Now leave the group
    await consumer.leaveGroup()

    // Verify that we've left
    strictEqual(consumer.memberId, null)
  } finally {
    await consumer.close(true)
  }
})

test('Consumer client - consume should return a MessagesStream', async () => {
  const consumer = createTestConsumer()
  const testTopic = getTestTopicName()

  try {
    // Create stream for consuming messages
    const stream = await consumer.consume({
      topics: [testTopic],
      mode: MessagesStreamModes.EARLIEST
    })

    // Verify that we get a MessagesStream instance
    ok(stream instanceof MessagesStream)
    strictEqual(typeof stream.close, 'function')

    // Close the stream
    await stream.close()
  } finally {
    await consumer.close(true)
  }
})

test('Consumer client - should consume and process messages', async () => {
  const consumer = createTestConsumer<string, string, string, string>({
    deserializers: stringDeserializers
  })
  const testTopic = getTestTopicName()

  // Produce some test messages
  await produceTestMessages(testTopic, 3)

  try {
    // Consume messages
    const stream = await consumer.consume({
      topics: [testTopic],
      mode: MessagesStreamModes.EARLIEST,
      autocommit: false
    })

    // Collect messages
    const messages = []
    for await (const message of stream) {
      messages.push(message)
      if (messages.length >= 3) {
        break
      }
    }

    // Verify we received all messages with correct content
    strictEqual(messages.length, 3)

    for (let i = 0; i < 3; i++) {
      deepStrictEqual(messages[i].key, `key-${i}`, `Message ${i} should have correct key`)
      deepStrictEqual(messages[i].value, `value-${i}`, `Message ${i} should have correct value`)
      deepStrictEqual(
        messages[i].headers.get('headerKey'),
        `headerValue-${i}`,
        `Message ${i} should have correct header`
      )
      strictEqual(messages[i].topic, testTopic, `Message ${i} should have correct topic`)
      strictEqual(typeof messages[i].offset, 'bigint', `Message ${i} should have bigint offset`)
      strictEqual(typeof messages[i].timestamp, 'bigint', `Message ${i} should have bigint timestamp`)
    }

    // Close the stream properly
    await stream.close()
  } finally {
    await consumer.close(true)
  }
})

test('Consumer client - listOffsets should return partition offsets', async () => {
  const consumer = createTestConsumer()
  const testTopic = getTestTopicName()

  // Produce some test messages
  await produceTestMessages(testTopic, 3)

  try {
    // List offsets for the topic
    const offsets = await consumer.listOffsets({ topics: [testTopic] })

    // Verify structure of returned offsets
    ok(offsets instanceof Map)
    strictEqual(offsets.has(testTopic), true)

    const topicOffsets = offsets.get(testTopic)!
    strictEqual(Array.isArray(topicOffsets), true)
    strictEqual(topicOffsets.length > 0, true)

    // Partition 0 should have at least 3 messages
    strictEqual(typeof topicOffsets[0], 'bigint')
    ok(topicOffsets[0] >= 3n)
  } finally {
    await consumer.close()
  }
})

test('Consumer client - commit should commit offsets', async () => {
  const consumer = createTestConsumer<string, string, string, string>({
    deserializers: stringDeserializers
  })
  const testTopic = getTestTopicName()

  // Produce some test messages
  await produceTestMessages(testTopic, 3)

  try {
    // Consume messages
    const stream = await consumer.consume({
      topics: [testTopic],
      mode: MessagesStreamModes.EARLIEST,
      autocommit: false
    })

    // Read one message
    const message = await new Promise(resolve => {
      stream.once('data', message => {
        resolve(message)
      })
    })

    // Commit the message's offset
    await consumer.commit({
      offsets: [
        {
          topic: testTopic,
          partition: 0,
          offset: (message as any).offset,
          leaderEpoch: 0
        }
      ]
    })

    // Close the stream
    await stream.close()

    // Query committed offsets
    const committed = await consumer.listCommittedOffsets({
      topics: [{ topic: testTopic, partitions: [0] }]
    })

    // Verify committed offset
    ok(committed instanceof Map)
    strictEqual(committed.has(testTopic), true)

    const topicOffsets = committed.get(testTopic)!
    strictEqual(Array.isArray(topicOffsets), true)
    strictEqual(typeof topicOffsets[0], 'bigint')
    strictEqual(topicOffsets[0], (message as any).offset)
  } finally {
    await consumer.close(true)
  }
})

test('Consumer client - fetch should fetch messages directly', async () => {
  const consumer = createTestConsumer()
  const testTopic = getTestTopicName()

  // Produce some test messages
  await produceTestMessages(testTopic, 3)

  try {
    // Get metadata to find partition leader
    await consumer.topics.trackAll(testTopic)
    const metadata = await consumer.metadata({ topics: [testTopic] })
    const topicMetadata = metadata.topics.get(testTopic)!
    const partitionLeader = topicMetadata.partitions[0].leader

    // Fetch messages directly
    const response = await consumer.fetch({
      node: partitionLeader,
      topics: [
        {
          topicId: '',
          partitions: [
            {
              partition: 0,
              currentLeaderEpoch: 0,
              fetchOffset: 0n,
              lastFetchedEpoch: 0,
              partitionMaxBytes: 1048576
            }
          ]
        }
      ]
    })

    // Verify response structure
    strictEqual(typeof response.sessionId, 'number')
    strictEqual(Array.isArray(response.topics), true)
    strictEqual(response.topics.length, 1)
    strictEqual(response.topics[0].name, testTopic)
    strictEqual(Array.isArray(response.topics[0].partitions), true)
    strictEqual(response.topics[0].partitions.length, 1)

    // Verify we got some records
    const partition = response.topics[0].partitions[0]
    strictEqual(typeof partition.partitionIndex, 'number')
    strictEqual(typeof partition.highWatermark, 'bigint')
    strictEqual(partition.errorCode, 0)
    ok(partition.records)
    strictEqual(typeof partition.records.size, 'number')
    strictEqual(partition.records.size > 0, true)
  } finally {
    await consumer.close()
  }
})

test('Consumer client - close should handle force closing with active streams', async () => {
  const consumer = createTestConsumer()
  const testTopic = getTestTopicName()

  // Create a stream
  const stream = await consumer.consume({
    topics: [testTopic],
    mode: MessagesStreamModes.EARLIEST
  })

  // Verify stream is created
  ok(stream instanceof MessagesStream)

  // Now force close the consumer
  await consumer.close(true)

  // Verify consumer is closed
  strictEqual(consumer.closed, true)

  // Stream should also be closed/destroyed
  strictEqual(stream.destroyed, true)
})